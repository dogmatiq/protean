package generator

import (
	"fmt"
	"path"
	"strings"

	"github.com/dave/jennifer/jen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// generateFile generates a Go file for the given input .proto file.
func generateFile(
	req *pluginpb.CodeGeneratorRequest,
	f *descriptorpb.FileDescriptorProto,
	params parameters,
	proteanVersion string,
) (*pluginpb.CodeGeneratorResponse_File, bool, error) {
	services := f.GetService()
	if len(services) == 0 {
		return nil, false, nil
	}

	pkgPath, pkgName, err := goPackage(f)
	if err != nil {
		return nil, false, err
	}

	out := jen.NewFilePathName(pkgPath, pkgName)

	out.HeaderComment("Code generated by protoc-gen-go-protean. DO NOT EDIT.")
	out.HeaderComment("versions:")
	out.HeaderComment(fmt.Sprintf("// 	protoc-gen-go-protean v%s", proteanVersion))
	out.HeaderComment(fmt.Sprintf("// 	protoc                v%s", formatProtocVersion(req)))
	out.HeaderComment(fmt.Sprintf("// source: %s", f.GetName()))

	for _, s := range services {
		if err := generateCodeForService(out, req, f, s); err != nil {
			return nil, false, err
		}
	}

	var w strings.Builder
	if err := out.Render(&w); err != nil {
		return nil, false, err
	}

	return &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(outputFileName(params, f)),
		Content: proto.String(w.String()),
	}, true, nil
}

// outputFileName returns the name of the file to be generated from the given
// input file.
func outputFileName(params parameters, desc *descriptorpb.FileDescriptorProto) string {
	n := strings.TrimPrefix(desc.GetName(), params.Module)

	if ext := path.Ext(n); ext == ".proto" || ext == ".protodevel" {
		n = strings.TrimSuffix(n, ext)
	}

	return n + "_protean.pb.go"
}

// formatProtocVersion formats the protoc version provided in the request for
// use in a file header.
func formatProtocVersion(req *pluginpb.CodeGeneratorRequest) string {
	v := req.GetCompilerVersion()

	s := fmt.Sprintf(
		"%d.%d.%d",
		v.GetMajor(),
		v.GetMinor(),
		v.GetPatch(),
	)

	if suffix := v.GetSuffix(); suffix != "" {
		s += "-" + suffix
	}

	return s
}

// generateCodeForService generates all of the code necessary for a single
// Protocol Buffers service.
func generateCodeForService(
	out *jen.File,
	req *pluginpb.CodeGeneratorRequest,
	f *descriptorpb.FileDescriptorProto,
	s *descriptorpb.ServiceDescriptorProto,
) error {
	if err := generateInterface(
		out,
		req,
		f,
		s,
	); err != nil {
		return err
	}

	generateServiceRegisterFunction(
		out,
		req,
		f,
		s,
	)

	generateServiceImpl(
		out,
		req,
		f,
		s,
	)

	for _, m := range s.GetMethod() {
		generateMethodImpl(out, req, f, s, m)

		if m.GetClientStreaming() || m.GetServerStreaming() {
			generateStreamingCallConstructor(
				out,
				req,
				f,
				s,
				m,
			)

			generateStreamingCallImpl(
				out,
				req,
				f,
				s,
				m,
			)
		} else {
			generateUnaryCallConstructor(
				out,
				req,
				f,
				s,
				m,
			)

			generateUnaryCallImpl(
				out,
				req,
				f,
				s,
				m,
			)
		}
	}

	return nil
}
