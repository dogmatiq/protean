package generator

import (
	"errors"
	"fmt"
	"path"
	"strings"

	"github.com/dave/jennifer/jen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// Generator produces a code generation response from a request.
type Generator struct {
	Version string
}

// Generate produces a code generation response for the given request.
func (g *Generator) Generate(req *pluginpb.CodeGeneratorRequest) (*pluginpb.CodeGeneratorResponse, error) {
	params, err := parseParameters(req.GetParameter())
	if err != nil {
		return nil, err
	}

	protocVersion := formatProtocVersion(req)
	res := &pluginpb.CodeGeneratorResponse{}

	for _, n := range req.GetFileToGenerate() {
		for _, desc := range req.GetProtoFile() {
			if desc.GetName() == n {
				f, ok, err := g.generateFile(
					desc,
					params,
					protocVersion,
				)
				if err != nil {
					return nil, fmt.Errorf("%s: %w", desc.GetName(), err)
				}

				if ok {
					res.File = append(res.File, f)
				}
			}
		}
	}

	return res, nil
}

// generateFile generates a Go file for the given input protobuffers file.
func (g *Generator) generateFile(
	desc *descriptorpb.FileDescriptorProto,
	params parameters,
	protocVersion string,
) (*pluginpb.CodeGeneratorResponse_File, bool, error) {
	services := desc.GetService()
	if len(services) == 0 {
		return nil, false, nil
	}

	pkg, err := packageName(desc)
	if err != nil {
		return nil, false, err
	}

	f := jen.NewFile(pkg)

	header := "// Code generated by protoc-gen-go-harpy. DO NOT EDIT.\n"
	header += "// versions:\n"
	header += fmt.Sprintf("// 	protoc-gen-go v%s\n", g.Version)
	header += fmt.Sprintf("// 	protoc        v%s\n", protocVersion)
	header += fmt.Sprintf("// source: %s\n", desc.GetName())
	f.HeaderComment(header)

	for _, s := range services {
		g.generateService(f, s)
	}

	var w strings.Builder
	if err := f.Render(&w); err != nil {
		return nil, false, err
	}

	return &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(outputFileName(params, desc)),
		Content: proto.String(w.String()),
	}, true, nil
}

// generateService generates code for a single service definition.
func (g *Generator) generateService(f *jen.File, s *descriptorpb.ServiceDescriptorProto) {

}

// outputFileName returns the name of the file to be generated from the given
// input file.
func outputFileName(params parameters, desc *descriptorpb.FileDescriptorProto) string {
	n := strings.TrimPrefix(desc.GetName(), params.Module)

	if ext := path.Ext(n); ext == ".proto" || ext == ".protodevel" {
		n = strings.TrimSuffix(n, ext)
	}

	return n + "_harpy.pb.go"
}

// parsePackageOption parses the "go_package" option in the given file and
// returns the (unqualified) package name.
func packageName(desc *descriptorpb.FileDescriptorProto) (string, error) {
	pkg := desc.GetOptions().GetGoPackage()
	if pkg == "" {
		return "", errors.New("no 'go_package' option was specified")
	}

	// If a semi-colon is present, the part after the semi-colon is the actual
	// package name. Used when the import path and package name differ.
	//
	// Use of this option is discouraged. See
	// https://developers.google.com/protocol-buffers/docs/reference/go-generated
	if i := strings.Index(pkg, ";"); i != -1 {
		return pkg[i+1:], nil
	}

	return path.Base(pkg), nil
}

// formatProtocVersion formats the protoc version provided in the request for
// use in a file header.
func formatProtocVersion(req *pluginpb.CodeGeneratorRequest) string {
	v := req.GetCompilerVersion()

	s := fmt.Sprintf(
		"%d.%d.%d",
		v.GetMajor(),
		v.GetMinor(),
		v.GetPatch(),
	)

	if suffix := v.GetSuffix(); suffix != "" {
		s += "-" + suffix
	}

	return s
}
