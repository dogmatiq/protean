// Code generated by protoc-gen-go-harpy. DO NOT EDIT.
// versions:
// 	protoc-gen-go-harpy v0.0.0+0d2fa2b
// 	protoc              v3.17.3
// source: github.com/dogmatiq/harpy/internal/testservice/api.proto

package testservice

import (
	"context"
	"errors"
	harpy "github.com/dogmatiq/harpy/codegenapi"
	proto "google.golang.org/protobuf/proto"
)

// API is an interface for the harpy.test.API service.
//
// It is used for both clients and servers.
type API interface {
	Unary(context.Context, *Request) (*Response, error)
	ServerStream(context.Context, *Request, chan<- *Response) error
	ClientStream(context.Context, <-chan *Request) (*Response, error)
	BidirectionalStream(context.Context, <-chan *Request, chan<- *Response) error
}

// harpy_API_Service is an implementation of the harpy.Service
// interface for the API service.
type harpy_API_Service struct {
	service API
}

// RegisterHarpyAPIServer registers a API service with a Harpy server.
func RegisterHarpyAPIServer(server harpy.Server, service API) {
	server.RegisterService(&harpy_API_Service{service})
}

func (a *harpy_API_Service) Name() string {
	return "API"
}

func (a *harpy_API_Service) Package() string {
	return "harpy.test"
}

func (a *harpy_API_Service) LookupMethod(name string) (harpy.Method, bool) {
	switch name {
	case "Unary":
		return &harpy_API_Unary_Method{a.service}, true
	case "ServerStream":
		return &harpy_API_ServerStream_Method{a.service}, true
	case "ClientStream":
		return &harpy_API_ClientStream_Method{a.service}, true
	case "BidirectionalStream":
		return &harpy_API_BidirectionalStream_Method{a.service}, true
	default:
		return nil, false
	}
}

// harpy_API_Unary_Method is an implementation of the harpy.Method
// interface for the API.Unary() method.
type harpy_API_Unary_Method struct {
	service API
}

func (m *harpy_API_Unary_Method) Name() string {
	return "Unary"
}

func (m *harpy_API_Unary_Method) ClientStreaming() bool {
	return false
}

func (m *harpy_API_Unary_Method) ServerStreaming() bool {
	return false
}

func (m *harpy_API_Unary_Method) NewCall(ctx context.Context) harpy.Call {
	return newHarpy_API_Unary_Call(ctx, m.service)
}

// harpy_API_Unary_Call is an implementation of the harpy.Call
// interface for the API.Unary() method.
type harpy_API_Unary_Call struct {
	ctx     context.Context
	service API
	done    chan struct{}
	res     *Response
	err     error
}

// newHarpy_API_Unary_Call returns a new harpy.Call for the API.Unary() method.
func newHarpy_API_Unary_Call(ctx context.Context, service API) harpy.Call {
	return &harpy_API_Unary_Call{ctx, service, make(chan struct{}), nil, nil}
}

func (c *harpy_API_Unary_Call) Recv() (proto.Message, bool, error) {
	select {
	case <-c.ctx.Done():
		return nil, false, c.ctx.Err()
	case <-c.done:
		return c.res, c.err != nil, c.err
	}
}

func (c *harpy_API_Unary_Call) Send(unmarshal harpy.RawMessage) error {
	req := &Request{}
	if err := unmarshal(req); err != nil {
		return err
	}

	c.res, c.err = c.service.Unary(c.ctx, req)
	return nil
}

func (c *harpy_API_Unary_Call) Done() {}

// harpy_API_ServerStream_Method is an implementation of the harpy.Method
// interface for the API.ServerStream() method.
type harpy_API_ServerStream_Method struct {
	service API
}

func (m *harpy_API_ServerStream_Method) Name() string {
	return "ServerStream"
}

func (m *harpy_API_ServerStream_Method) ClientStreaming() bool {
	return false
}

func (m *harpy_API_ServerStream_Method) ServerStreaming() bool {
	return true
}

func (m *harpy_API_ServerStream_Method) NewCall(ctx context.Context) harpy.Call {
	return newHarpy_API_ServerStream_Call(ctx, m.service)
}

// harpy_API_ServerStream_Call is an implementation of the harpy.Call
// interface for the API.ServerStream() method.
type harpy_API_ServerStream_Call struct {
	ctx     context.Context
	service API
	in      chan *Request
	out     chan *Response
	err     error
}

// newHarpy_API_ServerStream_Call returns a new harpy.Call for the API.ServerStream() method.
func newHarpy_API_ServerStream_Call(ctx context.Context, service API) harpy.Call {
	c := &harpy_API_ServerStream_Call{ctx, service, make(chan *Request, 1), make(chan *Response, 1), nil}
	go c.run()
	return c
}

func (c *harpy_API_ServerStream_Call) Recv() (proto.Message, bool, error) {
	select {
	case <-c.ctx.Done():
		return nil, false, c.ctx.Err()
	case res, ok := <-c.out:
		if ok {
			return res, true, nil
		}
		return nil, false, c.err
	}
}

func (c *harpy_API_ServerStream_Call) Send(unmarshal harpy.RawMessage) error {
	req := &Request{}
	if err := unmarshal(req); err != nil {
		return err
	}

	select {
	case <-c.ctx.Done():
		return c.ctx.Err()
	case c.in <- req:
		return nil
	}
}

func (c *harpy_API_ServerStream_Call) Done() {
	close(c.in)
}

func (c *harpy_API_ServerStream_Call) run() {
	defer close(c.out)

	select {
	case <-c.ctx.Done():
		c.err = c.ctx.Err()
	case req, ok := <-c.in:
		if ok {
			c.err = c.service.ServerStream(c.ctx, req, c.out)
		} else {
			c.err = errors.New("Done() was called without sending a request")
		}
	}
}

// harpy_API_ClientStream_Method is an implementation of the harpy.Method
// interface for the API.ClientStream() method.
type harpy_API_ClientStream_Method struct {
	service API
}

func (m *harpy_API_ClientStream_Method) Name() string {
	return "ClientStream"
}

func (m *harpy_API_ClientStream_Method) ClientStreaming() bool {
	return true
}

func (m *harpy_API_ClientStream_Method) ServerStreaming() bool {
	return false
}

func (m *harpy_API_ClientStream_Method) NewCall(ctx context.Context) harpy.Call {
	return newHarpy_API_ClientStream_Call(ctx, m.service)
}

// harpy_API_ClientStream_Call is an implementation of the harpy.Call
// interface for the API.ClientStream() method.
type harpy_API_ClientStream_Call struct {
	ctx     context.Context
	service API
	in      chan *Request
	out     chan *Response
	err     error
}

// newHarpy_API_ClientStream_Call returns a new harpy.Call for the API.ClientStream() method.
func newHarpy_API_ClientStream_Call(ctx context.Context, service API) harpy.Call {
	c := &harpy_API_ClientStream_Call{ctx, service, make(chan *Request, 1), make(chan *Response, 1), nil}
	go c.run()
	return c
}

func (c *harpy_API_ClientStream_Call) Recv() (proto.Message, bool, error) {
	select {
	case <-c.ctx.Done():
		return nil, false, c.ctx.Err()
	case res, ok := <-c.out:
		if ok {
			return res, true, nil
		}
		return nil, false, c.err
	}
}

func (c *harpy_API_ClientStream_Call) Send(unmarshal harpy.RawMessage) error {
	req := &Request{}
	if err := unmarshal(req); err != nil {
		return err
	}

	select {
	case <-c.ctx.Done():
		return c.ctx.Err()
	case c.in <- req:
		return nil
	}
}

func (c *harpy_API_ClientStream_Call) Done() {
	close(c.in)
}

func (c *harpy_API_ClientStream_Call) run() {
	defer close(c.out)

	res, err := c.service.ClientStream(c.ctx, c.in)
	if err != nil {
		c.err = err
	} else {
		c.out <- res // buffered, never blocks
	}
}

// harpy_API_BidirectionalStream_Method is an implementation of the harpy.Method
// interface for the API.BidirectionalStream() method.
type harpy_API_BidirectionalStream_Method struct {
	service API
}

func (m *harpy_API_BidirectionalStream_Method) Name() string {
	return "BidirectionalStream"
}

func (m *harpy_API_BidirectionalStream_Method) ClientStreaming() bool {
	return true
}

func (m *harpy_API_BidirectionalStream_Method) ServerStreaming() bool {
	return true
}

func (m *harpy_API_BidirectionalStream_Method) NewCall(ctx context.Context) harpy.Call {
	return newHarpy_API_BidirectionalStream_Call(ctx, m.service)
}

// harpy_API_BidirectionalStream_Call is an implementation of the harpy.Call
// interface for the API.BidirectionalStream() method.
type harpy_API_BidirectionalStream_Call struct {
	ctx     context.Context
	service API
	in      chan *Request
	out     chan *Response
	err     error
}

// newHarpy_API_BidirectionalStream_Call returns a new harpy.Call for the API.BidirectionalStream() method.
func newHarpy_API_BidirectionalStream_Call(ctx context.Context, service API) harpy.Call {
	c := &harpy_API_BidirectionalStream_Call{ctx, service, make(chan *Request, 1), make(chan *Response, 1), nil}
	go c.run()
	return c
}

func (c *harpy_API_BidirectionalStream_Call) Recv() (proto.Message, bool, error) {
	select {
	case <-c.ctx.Done():
		return nil, false, c.ctx.Err()
	case res, ok := <-c.out:
		if ok {
			return res, true, nil
		}
		return nil, false, c.err
	}
}

func (c *harpy_API_BidirectionalStream_Call) Send(unmarshal harpy.RawMessage) error {
	req := &Request{}
	if err := unmarshal(req); err != nil {
		return err
	}

	select {
	case <-c.ctx.Done():
		return c.ctx.Err()
	case c.in <- req:
		return nil
	}
}

func (c *harpy_API_BidirectionalStream_Call) Done() {
	close(c.in)
}

func (c *harpy_API_BidirectionalStream_Call) run() {
	defer close(c.out)
	c.err = c.service.BidirectionalStream(c.ctx, c.in, c.out)
}
